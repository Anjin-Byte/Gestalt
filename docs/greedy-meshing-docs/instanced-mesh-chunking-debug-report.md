# InstancedMesh Chunking Issue - Debug Report

## Problem Statement

When rendering voxelized models using Three.js with WebGPU, only approximately 1/3 of the voxels render when using chunked `InstancedMesh` objects. The chunking was implemented to avoid a `RangeError: GPUDevice.createBuffer: bufferSize(690657408) exceeds max buffer size` error that occurred with large voxel counts.

## Environment

- Three.js with WebGPU renderer (`WebGPURenderer`)
- Voxel data generated by Rust/wgpu voxelizer via WASM
- Model: Stanford Dragon (~1.5M voxels split into 3 chunks of ~524K each)

## Original Issue

Single `InstancedMesh` with ~1.5M instances caused a ~690MB buffer allocation, exceeding WebGPU's buffer size limit (~256MB typical).

## Solution Implemented

Split voxels into multiple `InstancedMesh` objects with ~524K instances each (~32MB per chunk).

---

## Debugging Attempts

### Attempt 1: Async Progressive Building

**Approach:** Create meshes lazily using `requestAnimationFrame`, adding one chunk per frame.

**Result:** Failed - Only partial rendering occurred.

**Code Pattern:**
```typescript
const buildNextChunk = () => {
  // Build one chunk
  group.add(instanced);
  if (moreChunks) requestAnimationFrame(buildNextChunk);
};
requestAnimationFrame(buildNextChunk);
```

---

### Attempt 2: Lazy Mesh Creation (One Per Frame)

**Approach:** Similar to attempt 1 but with different timing/ordering.

**Result:** Failed - Same partial rendering issue.

---

### Attempt 3: Synchronous Building Before Return

**Approach:** Build all chunks synchronously in a loop before returning the group, ensuring complete model is ready when added to scene.

**Result:** Failed - Partial rendering persisted.

**Code Pattern:**
```typescript
for (let chunkIndex = 0; chunkIndex < numMeshChunks; chunkIndex++) {
  // Build chunk synchronously
  group.add(instanced);
}
return group; // All chunks added before return
```

---

### Attempt 4: Separate BoxGeometry Per Chunk

**Approach:** Create a new `BoxGeometry` instance for each chunk instead of sharing geometry, to avoid potential shared state issues.

**Result:** Failed - No improvement.

**Code Pattern:**
```typescript
for (let chunkIndex = 0; chunkIndex < numMeshChunks; chunkIndex++) {
  const chunkGeometry = new BoxGeometry(voxelSize, voxelSize, voxelSize);
  const instanced = new InstancedMesh(chunkGeometry, material, chunkCount);
  // ...
}
```

---

### Attempt 5: MeshBasicMaterial Instead of MeshStandardMaterial

**Approach:** Use `MeshBasicMaterial` to rule out WebGPU shader compilation issues with `MeshStandardMaterial` and `InstancedMesh`.

**Result:** Pending testing.

**Code Pattern:**
```typescript
const material = new MeshBasicMaterial({
  color: voxelColor
});
```

---

## Diagnostic Findings

### Logging Output Confirmed:

1. **All 3 chunks are created** with valid instance counts
2. **Position data is correct** - spans from `[-0.499, -0.499, -0.499]` to `[0.499, 0.499, 0.499]`
3. **Bounding boxes are correct** and cover different Z ranges:
   - Chunk 0: Z range ~[-0.50, -0.24]
   - Chunk 1: Z range ~[-0.25, 0.26]
   - Chunk 2: Z range ~[0.25, 0.50]
4. **No errors thrown** during chunk creation
5. **Points mode works correctly** - only cubes (InstancedMesh) mode has issues

### Console Log Example:

```
[viewer] cubes chunking voxels=1573440 meshChunkSize=524288 numMeshChunks=3
[viewer] chunk added index=0 instances=524288 bbox=[...] bsphere=r=0.38
[viewer] chunk added index=1 instances=524288 bbox=[...] bsphere=r=0.39
[viewer] chunk added index=2 instances=524864 bbox=[...] bsphere=r=0.38
[viewer] voxels cubes complete voxels=1573440 meshChunks=3 ms=XXX
```

---

## Working Hypothesis

This appears to be a **Three.js WebGPU renderer bug** with multiple `InstancedMesh` objects in the same scene. The data is correct, the meshes are created properly, but the WebGPU renderer fails to render all instances across multiple `InstancedMesh` objects.

---

## Potential Next Steps

1. **Test MeshBasicMaterial** - Currently pending
2. **Force WebGL fallback** - Test if issue is WebGPU-specific by setting `preferredRenderer: "webgl"`
3. **Single merged InstancedMesh with reduced count** - Reduce voxel resolution to stay under buffer limits
4. **Investigate Three.js WebGPU issues** - Search for known bugs with multiple InstancedMesh objects
5. **Try different Three.js version** - May be a regression or known issue in current version
6. **Custom shader approach** - Bypass InstancedMesh entirely with custom GPU instancing

---

## Files Modified

| File | Changes |
|------|---------|
| `apps/web/src/viewer/outputs.ts` | Implemented chunking in `buildVoxels()`, added logging, tried various fixes |

---

## Current Code State

The current implementation in `outputs.ts` uses:
- Synchronous chunk building
- Separate `BoxGeometry` per chunk
- `MeshBasicMaterial` (latest change)
- `frustumCulled = false` on each `InstancedMesh`
- Extensive logging for diagnostics

```typescript
const buildVoxels = (output: Extract<ModuleOutput, { kind: "voxels" }>) => {
  // ... points mode handling ...

  const buildStart = performance.now();
  const voxelColor = colorFromTuple(output.voxels.color);
  const material = new MeshBasicMaterial({ color: voxelColor });

  const meshChunkSize = Math.max(1, Math.min(chunkSize, voxelCount));
  const numMeshChunks = Math.ceil(voxelCount / meshChunkSize);

  const matrix = new Matrix4();
  const position = new Vector3();

  for (let chunkIndex = 0; chunkIndex < numMeshChunks; chunkIndex++) {
    const chunkStart = chunkIndex * meshChunkSize;
    const chunkEnd = Math.min(chunkStart + meshChunkSize, voxelCount);
    const chunkCount = chunkEnd - chunkStart;

    const chunkGeometry = new BoxGeometry(
      output.voxels.voxelSize,
      output.voxels.voxelSize,
      output.voxels.voxelSize
    );
    const instanced = new InstancedMesh(chunkGeometry, material, chunkCount);
    instanced.count = chunkCount;
    instanced.frustumCulled = false;

    for (let i = 0; i < chunkCount; i++) {
      const globalIndex = chunkStart + i;
      const posIndex = globalIndex * 3;
      position.set(positions[posIndex], positions[posIndex + 1], positions[posIndex + 2]);
      matrix.makeTranslation(position.x, position.y, position.z);
      instanced.setMatrixAt(i, matrix);
    }

    instanced.instanceMatrix.needsUpdate = true;
    instanced.computeBoundingBox();
    instanced.computeBoundingSphere();
    group.add(instanced);
  }

  return group;
};
```
